[{"title":"快速幂算法(例:a^b mod p)","url":"/2022/07/15/fast_power/","content":"\n# 介绍\n\n**快速幂**（**Exponentiation by squaring**，平方求幂）是一种简单而有效的小算法，它可以以O(log n)的时间复杂度计算乘方。快速幂不仅本身非常常见，而且后续很多算法也都会用到快速幂。\n\n### 为什么要使用快速幂？\n\n比如要计算以下式子：\n$$\n9^{10}=?\n$$\n传统算法是\n$$\n9^{10} = 9*9*9*9*9*9*9*9*9*9\n$$\n计算机要通过**9次**计算才能得出答案。而快速幂的方法就是通过平方来减少计算次数：\n$$\n9^{10}=(9*9)^{5}=(81*81)^{2}*81\n$$\n这样子就只需要**4次**。\n\n这样的时间复杂度是**O(log n)**，当次方很大时可以节省很多时间。\n\n### 算法实现\n\n##### 非递归版\n\n```pseudocode\nfast_power(a, b)\n\tans = 1\n    while(b)\n        if b % 2 == 1\t//当幂为奇数时\n            ans *= a\n            b -= 1\n        else\n            a *= a\n            b /= 2\n    return ans\n```\n\n在b % 2 == 1运行完成后，b必定是偶数，接下来会再次进行while循环进入到else里面，其实我们可以简化成一次循环，如下：\n\n```pseudocode\nfast_power(a, b)\n\tans = 1\n    while(b)\n        if b % 2 == 1\n            ans *= a\n        a *= a\n        b /= 2\n    return ans\n```\n\n##### 递归版（慎用）\n\n```pseudocode\nfast_power(a, b)\n\tif b <= 0\n    \treturn 1\n    if b % 2 == 1\t//当幂为奇数时\n    \tans = fast_power(a, b - 1) * a\n    else \n    \tans = fast_power(a * a, b / 2)\n    return ans\n```\n\n以上都要**注意变量a, b, ans的范围**。\n\n### 例题a^b\n\n\n\n题目：[牛客网](https://ac.nowcoder.com/acm/contest/996/A \"a^b\")\n$$\n求 a 的 b 次方对 p 取模的值，其中 0≤a,b,p≤10^9，p>0\n$$\n**输入描述：**\n\n> 三个用空格隔开的整数a,b和p。\n\n**输出描述：**\n\n> 一个整数，表示a^b mod p的值。\n\n##### **思路：**\n\n1. 最直接的思路就是算出a^b的值之后再模p，不管是否上述快速幂的方法，都存在一个很明显问题是 a^b 的范围大至10的9次方的10的9次方，**远超过了long long的范围**。\n\n2. 利用**快速幂+取模运算的性质**，可以快速的同时不会让数值超过范围，性质**(a * b) % p = (a % p * b % p) % p** \n\n   于是可以得到以下代码：\n\n   ```c++\n   typedef long long ll;\n   ll fast_power(ll a, ll b, ll p) {\n   \tll ans = 1;\n       a %= p;\n       while(b) {\n           if(b % 2 == 1) {\n               ans = (ans * a) % p;\n           a = (a * a) % p;\n           b /= 2;\n       }\n       return ans % p;\n   }\n   ```\n\n3. 其实还可以使用**位运算**，提升运行的速度，代码如下：\n\n   ```c++\n   typedef long long ll;\n   ll fast_power(ll a, ll b, ll p) {\n   \tll ans = 1;\n       a %= p;\n       while(b) {\n           if(b & 1) {\t\t// 如7二进制为0000 0111，1二进制为0000 0001，则7&1 = 0000 0001 = 1\n               ans = (ans * a) % p;\n           a = (a * a) % p;\n           b >>= 1;\t\t// 7二进制为0000 0111，向右位移一位为 0000 0011 = 3 （不足补0）\n       }\n       return ans % p;\n   }\n   ```\n\n   常见的位运算符有 与& 或| 右移>> 左移<< 异或^\n\n##### **最终代码：**\n\n```c++\n#include <iostream>\n\nusing namespace std;\n\ntypedef long long ll;\n\nll fast_power(ll a, ll b, ll p) {\n    a %= p;\n    ll ans = 1;\n    while(b) {\n        if(b & 1)\n            ans = (ans * a) % p;\n        a = (a * a) % p;\n        b >>= 1;\n    }\n    return ans % p;\n}\n\nint main() {\n    \n    ll a, b, p;\n    \n    cin >> a >> b >> p;\n    \n    cout << fast_power(a, b, p);\n    \n    return 0;\n}\n```\n\n\n\n> 参考资料：\n>\n> [1] [Pecco : 算法学习笔记(4)：快速幂](https://zhuanlan.zhihu.com/p/95902286)\n>\n> [2] [芸学习 : 【C++/算法】快速幂算法详解](https://www.bilibili.com/video/BV12r4y1w7tx?spm_id_from=333.337.search-card.all.click&vd_source=c155e4a52de51664d15aaf241c4a7656)\n","tags":["基本算法","快速幂","取模运算","位运算"],"categories":["基本算法"]},{"title":"最小生成树(Minimum Spanning Tree)","url":"/2022/02/23/minimum_spanning_tree/","content":"\n## 前言\n\n例题：[AizuOJ ALDS_12A](https://onlinejudge.u-aizu.ac.jp/courses/lesson/1/ALDS1/12/ALDS1_12_A)  &  [AizuOJ GRL_2_A](https://onlinejudge.u-aizu.ac.jp/courses/library/5/GRL/2/GRL_2_A )\n\n本题可以使用**普里姆(Prim)算法**或**克鲁斯卡尔(Kruskal)算法**进行实现。\n\n两种算法的简单比较：\n\n|         |      时间复杂度       | 最适合 |\n| :-----: | :-------------------: | :----: |\n|  Prim   |        O(n^2)         | 稠密图 |\n| Kruskal | O(E * log E)，E为边数 | 稀疏图 |\n\n视频：[最小生成树(Kruskal(克鲁斯卡尔)和Prim(普里姆))算法动画演示](https://www.bilibili.com/video/BV1Eb41177d1 \"WAY_zhong - BiliBili\")\n\n以下代码是 [AizuOJ GRL_2_A](https://onlinejudge.u-aizu.ac.jp/courses/library/5/GRL/2/GRL_2_A ) 的解法。\n\n## 普里姆算法\n\n代码如下：\n\n```c++\n#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <limits.h>\n\nusing namespace std;\n\n#define MAX 10000\n\ntypedef pair<int, int> PII;\n\nvector<PII> D[MAX]; \t//PII(id, w)\nint sum = 0, d[MAX];\n//int p[MAX];\nbool seen[MAX] = {false};\n\nint main() {\n\tint V, E, s, t, w;\n\n\tscanf(\"%d %d\", &V, &E);\n\n\tfor (int i = 0; i < V; i++) {\n\t\td[i] = INT_MAX;\n\t}\n\n\tfor (int i = 0; i < E; i++) {\n\t\tscanf(\"%d %d %d\", &s, &t, &w);\n\t\tD[s].push_back(PII(t, w));\n\t\tD[t].push_back(PII(s, w));\n\t}\n\n\tint ct = 0;\n\ts = 0;\n\tseen[0] = true;\n\n\twhile (ct < V - 1) {\n\t\tfor (int i = 0; i < D[s].size(); i++) {\n\t\t\tt = D[s][i].first;\n\t\t\tw = D[s][i].second;\n\t\t\tif (!seen[t] && d[t] > w) {\n\t\t\t\td[t] = w;\n//\t\t\t\tp[t] = u;\n\t\t\t}\n\t\t}\n\n\t\tint min = 0;\n\t\tfor (int i = 0; i < V; i++)\n\t\t\tif (!seen[i] && d[i] < d[min])\n\t\t\t\tmin = i;\n\n\t\tseen[min] = true;\n\t\ts = min;\n\t\tsum += d[min];\n\t\tct++;\n\t}\n\n\tprintf(\"%d\\n\", sum);\n\n\treturn 0;\n}\n```\n\n运行结果：\n\n| Lang | Status | Judge |  Time  | Memory | Code |\n| :--: | :----: | :---: | :----: | :----: | :--: |\n| C++  |   AC   | 20/20 | 00.22s | 6024KB | 861B |\n\n## 克鲁斯卡尔算法\n\n代码如下：\n\n```c++\n#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <limits.h>\n\nusing namespace std;\n\n#define MAX 10000\n\ntypedef struct {\n\tint v1, v2, w;\n} Info;\n\nvector<Info> D;\nint p[MAX], h[MAX], d[MAX];\n\nbool cmp(const Info a, const Info b) {\n\treturn a.w < b.w;\n}\n\nint find(int a) {\n\tif (p[a] != a) {\n\t\tp[a] = find(p[a]);\n\t}\n\treturn p[a];\n}\n\nvoid unite(int x, int y) {\n\tint rX = find(x);\n\tint rY = find(y);\n\n\tif (rX != rY) {\n\t\tif (h[rX] > h[rY])\n\t\t\tp[rY] = rX;\n\t\telse {\n\t\t\tp[rX] = rY;\n\t\t\tif (h[rX] == h[rY])\n\t\t\t\th[rY]++;\n\t\t}\n\t}\n}\n\n\nint main() {\n\tint V, E, sum = 0;\n\tint s, t, w;\n\n\tscanf(\"%d %d\", &V, &E);\n\n\tfor (int i = 0; i < V; i++) {\n\t\td[i] = INT_MAX;\n\t\tp[i] = i;\n\t\th[i] = 0;\n\t}\n\n\tfor (int i = 0; i < E; i++) {\n\t\tscanf(\"%d %d %d\", &s, &t, &w);\n\t\tInfo tmp = {s, t, w};\n\t\tD.push_back(tmp);\n\t}\n\n\tsort(D.begin(), D.end(), cmp);\n\n\tfor (int i = 0; i < E; i++) {\n\t\tif (find(D[i].v1) != find(D[i].v2)) {\n\t\t\tunite(D[i].v1, D[i].v2);\n\t\t\tsum += D[i].w;\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", sum);\n\n\treturn 0;\n}\n```\n\n运行结果：\n\n| Lang | Status | Judge |  Time  | Memory | Code  |\n| :--: | :----: | :---: | :----: | :----: | :---: |\n| C++  |   AC   | 20/20 | 00.02s | 4696KB | 1013B |\n\n  \n","tags":["图论","普里姆算法","克鲁斯卡尔算法","最小生成树"],"categories":["图论"]},{"title":"Hello World","url":"/2022/01/08/hello-world/","content":"emmm...\n"}]