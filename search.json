[{"title":"Linux学习笔记","url":"/2023/01/24/linux-note/","content":"# Linux学习笔记\n\nLinux学习记录，按照[韩顺平老师](https://space.bilibili.com/651245581 \"韩顺平 - Bilibili\")[视频](https://www.bilibili.com/video/BV1Sv411r7vd \"【小白入门 通俗易懂】2021韩顺平 一周学会Linux\")进行学习。\n\n## 目录结构\n\n> [Linux 系统目录结构 | 菜鸟教程](https://www.runoob.com/linux/linux-system-contents.html)\n\n### 基本介绍\n\n1. linux的文件系统是采用级**层式的树状**目录结构，在此结构中的最上层是**根目录“/”**。\n2.  在Linux世界里，一切皆文件。\n\n树状目录结构：\n\n![](https://www.runoob.com/wp-content/uploads/2014/06/d0c50-linux2bfile2bsystem2bhierarchy.jpg)\n\n### 目录解释\n\n- **/bin** [常用] (/usr/bin、 /usr/local/bin)是Binary的缩写，这个目录存放着最经常使用的命令\n- **/sbin** (/usr/sbin、 /usr/local/sbin)s就是Super User的意思，这里存放的是系统管理员使用的系统管理程序。\n- **/home** [常用]存放普通用户的主目录，在Linux中每个用户都有一个自己的目录，一般该目录名是以用户的账号命名\n- **/root** [常用]该目录为系统管理员，也称作超级权限者的用户主目录\n- **/lib** 系统开机所需要最基本的动态连接共享库，其作用类似于Windows里的DLL文件。几乎所有的应用程序都需要用到这些共享库\n- **/lost+found** 这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件\n- **/etc**[常用]所有的系统管理所需要的配置文件和子目录,比如安装mysql数据库 my.conf\n- **/usr** [常用]这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似与windows下的program files目录。\n- **/boot** [常用] 存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件\n- **/proc** [不能动]这个目录是一个虚拟的目录，它是系统内存的映射，访问这个目录来获取系统信息\n- **/srv** [不能动]service缩写，该目录存放一些服务启动之后需要提取的数据\n- **/sys**[不能动]这是linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统 sysfs\n- **/tmp** 这个目录是用来存放一些临时文件的\n- **/dev**类似于windows的设备管理器，把所有的硬件用文件的形式存储/media[常用]linux系统会自动识别一些设备，例如U盘、光驱等等，当识别后，linux会把识别的设备挂载到这个目录下\n- **/mnt** [常用]系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将外部的存储挂载在/mnt/上，然后进入该目录就可以查看里的内容了。\n- **/opt** 这是给主机额外安装软件所摆放的目录。如安装ORACLE数据库就可放到该目录下。默认为空。\n- **/usr/local** [常用]这是另一个给主机额外安装软件所安装的目录。一般是通过编译源码方式安装的程序\n- **/var** [常用]这个目录中存放着在不断扩充着的东西,习惯将经常被修改的目录放在这个目录下。包括各种日志文件\n- **/selinux** [security-enhanced linux]SELinux是一种安全子系统，它能控制程序只能访问特定文件，有三种工作模式，可以自行设置.\n\n## Vim基本用法\n\nvim是vi的增强版，语法识别高亮显示等。。。\n\nvim <file> 用vim打开文件，没有则默认打开空文件\n\n### vim的三个模式\n\n- 一般模式\n- 输入模式\n- 命令行模式\n\n\n\n进入为一般模式，在一一般模式下按a/A，i/I，o/O按键进入输入模式，按Esc退回一般模式，在正常模式下按:进入命令行模式输入命令按Enter提交。\n\n下图对应一般模式-命令模式，底线命令模式-命令行模式：\n\n![](https://www.runoob.com/wp-content/uploads/2014/07/vim-vi-workmodel.png)\n\n### 一般模式指令\n\n- yy 复制当前行（5yy复制包括当前往下5行）\n- p 粘贴\n- dd 删除当前行（5dd删除包括当前往下5行）\n- gg 光标跳到第一行\n- G 光标跳到最后一行\n- <行号>gg/<行号>G 光标跳到指定行（例如：20gg/20G跳转到行号20）\n- /<关键词> 搜索关键词，n查找下一个（例如/hello）\n\n### 命令行模式指令\n\n- :h 查看help.txt\n\n- :w 保存写入\n- :q 退出\n- :q! 强制退出\n- :wq 保存写入并退出\n- :<行号> 跳转到指定行号（如：:20 跳转到行号20）\n- :set nu 临时设置行号\n- :set nonu 取消行号\n\n### Vim键盘图\n\n![](https://www.runoob.com/wp-content/uploads/2015/10/vi-vim-cheat-sheet-sch.gif)\n\n## 用户管理\n\n### 相关指令（命令）\nsu - <user> 切换用户\n\nlogout/exit 登出\n\nid <user> 查看用户信息\n\nwhoami 查看当前会话用户\n\nwho am i 查看登录的用户信息 （第一次会话的）\n\n\n\nuseradd <user> 创建用户\n\n- -r 指定家目录\n- -g 添加到指定用户组（不添加将创建与该用户同名的组，并指定该组）\n\npasswd <user> 修改用户密码\n\nuserdel <user> 删除用户\n\n- -r 同时删除家目录\n\nusermod [选项] <user> 修改用户属性\n\n- -g 修改用户组\n- -d 修改用户家目录（需要有一定权限）\n\n\n\ngroupadd <group> 创建用户组\n\ngroupdel <group> 删除用户组\n\n\n\n### 用户和组相关文件\n\n/etc/passwd文件\n\n- 用户的配置文件，记录用户的各种信息\n- 每行格式： 用户名:口令:用户标识号:组标识号:注释性描述:主目录:Shell登录\n\n/etc/shadow文件\n\n- 口令的配置文件\n- 每行格式： 用户名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志\n\n/etc/group文件\n\n- 组的配置文件，记录Linux包含的组的信息\n- 每行格式： 组名:口令:组标识号:组内用户列表\n\n### 忘记密码解决办法\n\n[Linux 忘记密码解决方法 | 菜鸟教程](https://www.runoob.com/linux/linux-forget-password.html)\n\n## 运行级别\n\n### 基本介绍\n\n运行级别说明：\n\n- 0:关机\n- 1:单用户【找回丢失密码】\n- 2：多用户状态没有网络服务\n- 3：多用户状态有网络服务\n- 4：系统未使用保留给用户\n- 5：图形界面\n- 6：系统重启\n\n常用运行级别是3和5，也可以指定默认运行级别\n\n演示应用实例命令：**init [0123456]** \n\n应用案例：通过init 来切换不同的运行级别，比如动 5-3，然后关机。\n\n- systemctl get-default 查看默认运行级别\n- systemctl set-default <级别> 设置默认运行级别\n  - multi-user.target 多用户级别\n  - graphical.target 图形级别\n\n## 帮助指令\n\n- man <命令或配置文件> 获得帮助信息（man ls查看ls命令的帮助信息）\n- help [命令] 获取shell内置命令的帮助信息（如help cd）\n\n## 文件目录指令\n\npwd 显示当前工作目录的绝对路径\nls [选项] [目录/文件] 查看显示目录/文件信息\n\n- -a 显示当前目录所有的文件和目录，包括隐藏的\n- -l 已列表的方式显示信息（等同于ll）\n- -i \n- -h 转换大小单位\n\ncd <path> 切换到指定目录\n  - cd ~ 切换到家目录\n  - cd .. 返回上一级目录\n\n\n\nmkdir [选项] <目录> 创建目录\n\n- -p 创建多级目录\n\nrmdir <目录> 删除空目录\nrm [选项] <文件/目录> 删除目录/文件\n\n- -r 递归删除整个目录\n- -f 强制删除不提示\n- -rf 包含上面两者\n\ntouch <file> 创建一个空文件\n\ncp [选项] <source> <dest> 复制文件/目录到指定目录\n\n- -r 递归复制整个目录\n- \\cp 强制覆盖不提示\n\nmv 移动文件与目录或重命名\n\n- mv <oldName> <newName> 重命名\n- mv <file/dir> <path> 移动文件/目录\n\n\n\ncat [选项] 查看文件内容\n\n- -n 显示行号\n- cat [选项] <file> | more \n\n\n\nmore 基于VI编辑器的文本过滤器，以全屏幕的方式按页显示\n\n- Space  翻动下一页\n- Enter  翻动下一行\n- q 退出\n- Ctrl+F 翻动下一屏\n- Ctrl+B 翻动上一屏\n- = 输出当前行的行号\n- :f 输出文件名和当前行的行号\n\nless 分屏查看文件内容，与more类似但更强大，按需加载\n\n- Space  翻动下一页\n- PageDown 翻动下一页\n- PageUp 翻动上一页\n- /<keyword> 向下搜寻。 n：下一个 N：上一个\n- ?<keyword> 向上搜寻。 n：下一个 N：上一个\n- q 退出\n\n\n\necho [选项] <content>  输出内容到控制台\n\n- 如 echo $HOSTNAME 输出主机名\n- 如 echo $PATH 输出环境变量\n\nhead [选项] <file> 显示文件的头部内容，默认前十行\n\n- -n <lines> 显示前多少行\n- -c  <bytes> 显示前多少字节\n\ntail [选项] <file> 显示文件的尾部内容，默认后十行\n\n- -n <lines> 显示后多少行\n- -c  <bytes> 显示后多少字节\n- -f 实时监控文件变化\n\n\n\n'>' 输出重定向（覆盖）\n\n'>>' 追加\n\n- ls -l > 文件 列表的内容覆盖到文件\n- ls -al >> 文件 列表的内容追加到文件\n- cat 文件1 > 文件2 将文件1的内容覆盖到文件2\n- echo \"内容\"  >> 文件 追加内容到文件\n\n\n\nIn指令：软链接也称为符号链接，类似于windows里的快捷方式，主要存放了链接其他文件的路径\n\n- ln -s <原文件/目录> <软链接名> 给原文件/目录创建一个软链接（pwd查看仍在原文件/目录）\n\n\n\nhistory [数量] 查看已经执行过的历史命令，无参默认显示全部\n\n- !<编号> 执行历史命令中编号为<编号>的命令（如!5 执行编号为5的命令）\n\n## 时间日期指令\n\ndate 显示当前时间\ndate +%Y 显示当前年份\ndate +%m 显示当前月份\ndate +%d 显示当前是哪一天\ndate \"+%Y-%m-%d %H:%M:%S\" 显示年月日时分秒\ndate -s <字符串时间> 设置系统当前时间\n\n\n\ncal [选项] 显示当前日历，无参默认显示当前时间日历\n\n- cal 2023 显示2023年日历\n\n## 搜索查找指令\n\nfind [范围] [选项] 从指定目录向下递归遍历其各个子目录查找\n\n- -name <name> 按照指定的文件名查找\n- -user <user> 查找属于指定用户名的所有文件\n- -size <size> 按照指定的文件大小查找文件（单位K，M，G）\n  - find / -size +200M 查找/下大于200M的文件，-200M表示小于200M的文件\n\nlocate <file> 可以快速定位文件路径。\n\n- locate指令利用事先建立的系统中所有文件名称及路径的locate数据库实现快速定位给定的文件。\n- locate指令无需遍历整个文件系统,查询速度较快。\n- 为了保证查询结果的准确度，管理员必须定期更新locate时刻\n- updatedb 更新数据库\n\nwhich <cmd> 查询某个指令在哪个目录下\n\n\n\ngrep [选项] <内容> <源文件> 过滤查找\n\n- -n 显示匹配行及行号\n- -i 忽略字母大小写\n\n\n\n‘|’ 管道符 ，将前一个命令查询到的内容交给下一个命令\n\n- cat a.txt | grep \"hello\"    cat查询到的内容交给grep进行过滤查找\n\n## 压缩和解压\n\ngzip <file> 只能将文件压缩成.gz文件\n\ngunzip <file.gz> 解压.gz文件\n\n\n\nzip [选项] <name.zip> <file/dir> 压缩成name.zip文件\n\n- -r 递归压缩，即压缩目录\n\nunzip [选项] <file.zip> 解压\n\n- -d <dir> 指定解压后存放目录\n\n\n\ntar [选项] 打包、压缩或解压\n\n- -c 产生.tar打包文件\n- -v 显示详细信息\n- -f 指定压缩后的文件名\n- -z 通过gzip指令处理压缩解压\n- -j 通过bzip2指令处理压缩解压\n- -x 解包.tar文件\n- -C 指定解压目录\n- 常见用法\n  - tar -czvf <xxx.tar.gz> <file>... 压缩成.tar.gz\n  - tar -xzvf <xxx.tar.gz> 解压\n  - tar -tzvf <xxx.tar.gz> 列出压缩文件内容\n- [Linux tar 命令 |  菜鸟教程](https://www.runoob.com/linux/linux-comm-tar.html)\n\n\n\n## Linux组(权限)\n\n### 基本内容\n\n在linux中的每个用户必须属于一个组，不能独立于组外。在linux中每个文件有所有者、所在组、其它组的概念。\n\n\n\nls -ahl显示格式解释如下：\n\n|  文档属性   | 链接数 | 所有者  | 所属组  | 大小 | 修改时间      |\n| :---------: | ------ | ------- | ------- | ---- | ------------- |\n| drwx------. | 16     | wshape1 | wshape1 | 4.0K | 1月  25 14:17 |\n| -rw-r--r--. | 1      | root    | root    | 15K  | 1月  25 17:03 |\n\n![](https://www.runoob.com/wp-content/uploads/2014/06/file-llls22.jpg)\n\n文档属性：\n\n- 第一位：表示文档类型\n  - d 目录\n  - -文件\n  - l 链接文档\n  - b 装置文件里面的可供储存的接口设备(可随机存取装置)\n  - c 装置文件里面的串行端口设备，例如键盘、鼠标(一次性读取装置)\n- 第2到4位：所有者权限\n- 第3到5位：所属组权限\n- 第6到8位：其他组权限\n\n![](https://www.runoob.com/wp-content/uploads/2014/06/363003_1227493859FdXT.png)\n\n\n\n**rwx作用到文件**\n\n1. [**r**]代表可读(read):可以读取,查看字\n2. [**w**]代表可写(write)：可以修改，但是不代表可以删除该文件,删除一个文件的前提条件是对该文件所在的目录有写权限，才能删除该文件.\n3. [**x**]代表可执行(execute):可以被执行\n\n**rwx作用到目录**\n\n1. [**r**]代表可读(read)：可以读取，Is查看目录内容\n2. [**w**]代表可写(write)： 可以修改,对目录内创建+删除+重命名目录\n3. [**x**]代表可执行(execute)：可以进入该目录\n\n\n\n### 常用指令\n\nchown <user> <file/dir> 修改文件/目录所有者\n\nchgrp <group> <file/dir> 修改文件/目录所在组 \n\nchmod [选项] xyz <file/dir> 修改文件/目录权限\n\n","tags":["Linux","笔记"],"categories":["Linux"]},{"title":"快速幂算法(例:a^b mod p)","url":"/2022/07/15/fast_power/","content":"\n# 介绍\n\n**快速幂**（**Exponentiation by squaring**，平方求幂）是一种简单而有效的小算法，它可以以O(log n)的时间复杂度计算乘方。快速幂不仅本身非常常见，而且后续很多算法也都会用到快速幂。\n\n### 为什么要使用快速幂？\n\n比如要计算以下式子：\n$$\n9^{10}=?\n$$\n传统算法是\n$$\n9^{10} = 9*9*9*9*9*9*9*9*9*9\n$$\n计算机要通过**9次**计算才能得出答案。而快速幂的方法就是通过平方来减少计算次数：\n$$\n9^{10}=(9*9)^{5}=(81*81)^{2}*81\n$$\n这样子就只需要**4次**。\n\n这样的时间复杂度是**O(log n)**，当次方很大时可以节省很多时间。\n\n### 算法实现\n\n##### 非递归版\n\n```pseudocode\nfast_power(a, b)\n\tans = 1\n    while(b)\n        if b % 2 == 1\t//当幂为奇数时\n            ans *= a\n            b -= 1\n        else\n            a *= a\n            b /= 2\n    return ans\n```\n\n在b % 2 == 1运行完成后，b必定是偶数，接下来会再次进行while循环进入到else里面，其实我们可以简化成一次循环，如下：\n\n```pseudocode\nfast_power(a, b)\n\tans = 1\n    while(b)\n        if b % 2 == 1\n            ans *= a\n        a *= a\n        b /= 2\n    return ans\n```\n\n##### 递归版（慎用）\n\n```pseudocode\nfast_power(a, b)\n\tif b <= 0\n    \treturn 1\n    if b % 2 == 1\t//当幂为奇数时\n    \tans = fast_power(a, b - 1) * a\n    else \n    \tans = fast_power(a * a, b / 2)\n    return ans\n```\n\n以上都要**注意变量a, b, ans的范围**。\n\n### 例题a^b\n\n\n\n题目：[牛客网](https://ac.nowcoder.com/acm/contest/996/A \"a^b\")\n$$\n求 a 的 b 次方对 p 取模的值，其中 0≤a,b,p≤10^9，p>0\n$$\n**输入描述：**\n\n> 三个用空格隔开的整数a,b和p。\n\n**输出描述：**\n\n> 一个整数，表示a^b mod p的值。\n\n##### **思路：**\n\n1. 最直接的思路就是算出a^b的值之后再模p，不管是否上述快速幂的方法，都存在一个很明显问题是 a^b 的范围大至10的9次方的10的9次方，**远超过了long long的范围**。\n\n2. 利用**快速幂+取模运算的性质**，可以快速的同时不会让数值超过范围，性质**(a * b) % p = (a % p * b % p) % p** \n\n   于是可以得到以下代码：\n\n   ```c++\n   typedef long long ll;\n   ll fast_power(ll a, ll b, ll p) {\n   \tll ans = 1;\n       a %= p;\n       while(b) {\n           if(b % 2 == 1) {\n               ans = (ans * a) % p;\n           a = (a * a) % p;\n           b /= 2;\n       }\n       return ans % p;\n   }\n   ```\n\n3. 其实还可以使用**位运算**，提升运行的速度，代码如下：\n\n   ```c++\n   typedef long long ll;\n   ll fast_power(ll a, ll b, ll p) {\n   \tll ans = 1;\n       a %= p;\n       while(b) {\n           if(b & 1) {\t\t// 如7二进制为0000 0111，1二进制为0000 0001，则7&1 = 0000 0001 = 1\n               ans = (ans * a) % p;\n           a = (a * a) % p;\n           b >>= 1;\t\t// 7二进制为0000 0111，向右位移一位为 0000 0011 = 3 （不足补0）\n       }\n       return ans % p;\n   }\n   ```\n\n   常见的位运算符有 与& 或| 右移>> 左移<< 异或^\n\n##### **最终代码：**\n\n```c++\n#include <iostream>\n\nusing namespace std;\n\ntypedef long long ll;\n\nll fast_power(ll a, ll b, ll p) {\n    a %= p;\n    ll ans = 1;\n    while(b) {\n        if(b & 1)\n            ans = (ans * a) % p;\n        a = (a * a) % p;\n        b >>= 1;\n    }\n    return ans % p;\n}\n\nint main() {\n    \n    ll a, b, p;\n    \n    cin >> a >> b >> p;\n    \n    cout << fast_power(a, b, p);\n    \n    return 0;\n}\n```\n\n\n\n> 参考资料：\n>\n> [1] [Pecco : 算法学习笔记(4)：快速幂](https://zhuanlan.zhihu.com/p/95902286)\n>\n> [2] [芸学习 : 【C++/算法】快速幂算法详解](https://www.bilibili.com/video/BV12r4y1w7tx?spm_id_from=333.337.search-card.all.click&vd_source=c155e4a52de51664d15aaf241c4a7656)\n","tags":["基本算法","快速幂","取模运算","位运算"],"categories":["基本算法"]},{"title":"最小生成树(Minimum Spanning Tree)","url":"/2022/02/23/minimum_spanning_tree/","content":"\n## 前言\n\n例题：[AizuOJ ALDS_12A](https://onlinejudge.u-aizu.ac.jp/courses/lesson/1/ALDS1/12/ALDS1_12_A)  &  [AizuOJ GRL_2_A](https://onlinejudge.u-aizu.ac.jp/courses/library/5/GRL/2/GRL_2_A )\n\n本题可以使用**普里姆(Prim)算法**或**克鲁斯卡尔(Kruskal)算法**进行实现。\n\n两种算法的简单比较：\n\n|         |      时间复杂度       | 最适合 |\n| :-----: | :-------------------: | :----: |\n|  Prim   |        O(n^2)         | 稠密图 |\n| Kruskal | O(E * log E)，E为边数 | 稀疏图 |\n\n视频：[最小生成树(Kruskal(克鲁斯卡尔)和Prim(普里姆))算法动画演示](https://www.bilibili.com/video/BV1Eb41177d1 \"WAY_zhong - BiliBili\")\n\n以下代码是 [AizuOJ GRL_2_A](https://onlinejudge.u-aizu.ac.jp/courses/library/5/GRL/2/GRL_2_A ) 的解法。\n\n## 普里姆算法\n\n代码如下：\n\n```c++\n#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <limits.h>\n\nusing namespace std;\n\n#define MAX 10000\n\ntypedef pair<int, int> PII;\n\nvector<PII> D[MAX]; \t//PII(id, w)\nint sum = 0, d[MAX];\n//int p[MAX];\nbool seen[MAX] = {false};\n\nint main() {\n\tint V, E, s, t, w;\n\n\tscanf(\"%d %d\", &V, &E);\n\n\tfor (int i = 0; i < V; i++) {\n\t\td[i] = INT_MAX;\n\t}\n\n\tfor (int i = 0; i < E; i++) {\n\t\tscanf(\"%d %d %d\", &s, &t, &w);\n\t\tD[s].push_back(PII(t, w));\n\t\tD[t].push_back(PII(s, w));\n\t}\n\n\tint ct = 0;\n\ts = 0;\n\tseen[0] = true;\n\n\twhile (ct < V - 1) {\n\t\tfor (int i = 0; i < D[s].size(); i++) {\n\t\t\tt = D[s][i].first;\n\t\t\tw = D[s][i].second;\n\t\t\tif (!seen[t] && d[t] > w) {\n\t\t\t\td[t] = w;\n//\t\t\t\tp[t] = u;\n\t\t\t}\n\t\t}\n\n\t\tint min = 0;\n\t\tfor (int i = 0; i < V; i++)\n\t\t\tif (!seen[i] && d[i] < d[min])\n\t\t\t\tmin = i;\n\n\t\tseen[min] = true;\n\t\ts = min;\n\t\tsum += d[min];\n\t\tct++;\n\t}\n\n\tprintf(\"%d\\n\", sum);\n\n\treturn 0;\n}\n```\n\n运行结果：\n\n| Lang | Status | Judge |  Time  | Memory | Code |\n| :--: | :----: | :---: | :----: | :----: | :--: |\n| C++  |   AC   | 20/20 | 00.22s | 6024KB | 861B |\n\n## 克鲁斯卡尔算法\n\n代码如下：\n\n```c++\n#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <limits.h>\n\nusing namespace std;\n\n#define MAX 10000\n\ntypedef struct {\n\tint v1, v2, w;\n} Info;\n\nvector<Info> D;\nint p[MAX], h[MAX], d[MAX];\n\nbool cmp(const Info a, const Info b) {\n\treturn a.w < b.w;\n}\n\nint find(int a) {\n\tif (p[a] != a) {\n\t\tp[a] = find(p[a]);\n\t}\n\treturn p[a];\n}\n\nvoid unite(int x, int y) {\n\tint rX = find(x);\n\tint rY = find(y);\n\n\tif (rX != rY) {\n\t\tif (h[rX] > h[rY])\n\t\t\tp[rY] = rX;\n\t\telse {\n\t\t\tp[rX] = rY;\n\t\t\tif (h[rX] == h[rY])\n\t\t\t\th[rY]++;\n\t\t}\n\t}\n}\n\n\nint main() {\n\tint V, E, sum = 0;\n\tint s, t, w;\n\n\tscanf(\"%d %d\", &V, &E);\n\n\tfor (int i = 0; i < V; i++) {\n\t\td[i] = INT_MAX;\n\t\tp[i] = i;\n\t\th[i] = 0;\n\t}\n\n\tfor (int i = 0; i < E; i++) {\n\t\tscanf(\"%d %d %d\", &s, &t, &w);\n\t\tInfo tmp = {s, t, w};\n\t\tD.push_back(tmp);\n\t}\n\n\tsort(D.begin(), D.end(), cmp);\n\n\tfor (int i = 0; i < E; i++) {\n\t\tif (find(D[i].v1) != find(D[i].v2)) {\n\t\t\tunite(D[i].v1, D[i].v2);\n\t\t\tsum += D[i].w;\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", sum);\n\n\treturn 0;\n}\n```\n\n运行结果：\n\n| Lang | Status | Judge |  Time  | Memory | Code  |\n| :--: | :----: | :---: | :----: | :----: | :---: |\n| C++  |   AC   | 20/20 | 00.02s | 4696KB | 1013B |\n\n  \n","tags":["图论","普里姆算法","克鲁斯卡尔算法","最小生成树"],"categories":["图论"]},{"title":"Hello World","url":"/2022/01/08/hello-world/","content":"emmm...\n"}]