[{"title":"克鲁斯卡尔(Kruskal)算法","url":"/2022/02/23/kruskal/","content":"\n\n\n\n\n# 克鲁斯卡尔(Kruskal)算法\n\n- 用于生成’最小生成树‘\n- 时间复杂度O(E * log E) ，E为变数\n- 最适合用于稀疏图的算法\n\n推荐视频：[WAY_zhong - BiliBili](https://www.bilibili.com/video/BV1Eb41177d1)\n\n例题：[AizuOJ GRL_2_A](https://onlinejudge.u-aizu.ac.jp/courses/library/5/GRL/2/GRL_2_A )\n","tags":["图论","克鲁斯卡尔算法","Kruskal Algorithm"],"categories":["图论"]},{"title":"普里姆(Prim)算法","url":"/2022/02/23/prim/","content":"\n\n\n\n\n# 普里姆(Prim)算法\n\n- 用于生成’最小生成树‘\n- 时间复杂度O(n^2)\n- 最适合用于稠密图的算法\n\n推荐视频：[WAY_zhong - BiliBili](https://www.bilibili.com/video/BV1Eb41177d1)\n\n例题：[AizuOJ GRL_2_A](https://onlinejudge.u-aizu.ac.jp/courses/library/5/GRL/2/GRL_2_A )\n\n代码如下：\n\n```c++\n#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <limits.h>\n\nusing namespace std;\n\n#define MAX 10000\n\ntypedef pair<int, int> PII;\n\nvector<PII> D[MAX]; \t//PII(id, w)\nint sum = 0, d[MAX];\n//int p[MAX];\nbool seen[MAX] = {false};\n\nint main() {\n\tint V, E, s, t, w;\n\n\tscanf(\"%d %d\", &V, &E);\n\n\tfor (int i = 0; i < V; i++) {\n\t\td[i] = INT_MAX;\n\t}\n\n\tfor (int i = 0; i < E; i++) {\n\t\tscanf(\"%d %d %d\", &s, &t, &w);\n\t\tD[s].push_back(PII(t, w));\n\t\tD[t].push_back(PII(s, w));\n\t}\n\n\tint ct = 0;\n\ts = 0;\n\tseen[0] = true;\n\n\twhile (ct < V - 1) {\n\t\tfor (int i = 0; i < D[s].size(); i++) {\n\t\t\tt = D[s][i].first;\n\t\t\tw = D[s][i].second;\n\t\t\tif (!seen[t] && d[t] > w) {\n\t\t\t\td[t] = w;\n//\t\t\t\tp[t] = u;\n\t\t\t}\n\t\t}\n\n\t\tint min = 0;\n\t\tfor (int i = 0; i < V; i++)\n\t\t\tif (!seen[i] && d[i] < d[min])\n\t\t\t\tmin = i;\n\n\t\tseen[min] = true;\n\t\ts = min;\n\t\tsum += d[min];\n\t\tct++;\n\t}\n\n\tprintf(\"%d\\n\", sum);\n\n\treturn 0;\n}\n```\n\n","tags":["图论","普里姆算法","Prim Algorithm"],"categories":["图论"]},{"title":"Hello World","url":"/2022/01/08/hello-world/","content":"emmm...\n"}]