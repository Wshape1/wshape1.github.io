[{"title":"Linux学习笔记","url":"/2023/01/24/linux-note/","content":"# Linux学习笔记\n\nLinux学习记录，按照[韩顺平老师](https://space.bilibili.com/651245581 \"韩顺平 - Bilibili\")[视频](https://www.bilibili.com/video/BV1Sv411r7vd \"【小白入门 通俗易懂】2021韩顺平 一周学会Linux\")进行学习。\n\n## 目录结构\n\n> [Linux 系统目录结构 | 菜鸟教程](https://www.runoob.com/linux/linux-system-contents.html)\n\n### 基本介绍\n\n1. linux的文件系统是采用级**层式的树状**目录结构，在此结构中的最上层是**根目录“/”**。\n2.  在Linux世界里，一切皆文件。\n\n树状目录结构：\n\n```pseudocode\n/\n├── bin -> usr/bin\n├── boot\n├── dev\n├── etc\n├── home\n├── lib -> usr/lib\n├── lib64 -> usr/lib64\n├── lost+found\n├── media\n├── mnt\n├── opt\n├── proc\n├── root\n├── run\n├── sbin -> usr/sbin\n├── srv\n├── sys\n├── tmp\n├── usr\n└── var\n```\n\n![](https://www.runoob.com/wp-content/uploads/2014/06/d0c50-linux2bfile2bsystem2bhierarchy.jpg)\n\n### 目录解释\n\n- **/bin** [常用] (/usr/bin、 /usr/local/bin)是Binary的缩写，这个目录存放着最经常使用的命令\n- **/sbin** (/usr/sbin、 /usr/local/sbin)s就是Super User的意思，这里存放的是系统管理员使用的系统管理程序。\n- **/home** [常用]存放普通用户的主目录，在Linux中每个用户都有一个自己的目录，一般该目录名是以用户的账号命名\n- **/root** [常用]该目录为系统管理员，也称作超级权限者的用户主目录\n- **/lib** 系统开机所需要最基本的动态连接共享库，其作用类似于Windows里的DLL文件。几乎所有的应用程序都需要用到这些共享库\n- **/lost+found** 这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件\n- **/etc**[常用]所有的系统管理所需要的配置文件和子目录,比如安装mysql数据库 my.conf\n- **/usr** [常用]这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似与windows下的program files目录。\n- **/boot** [常用] 存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件\n- **/proc** [不能动]这个目录是一个虚拟的目录，它是系统内存的映射，访问这个目录来获取系统信息\n- **/srv** [不能动]service缩写，该目录存放一些服务启动之后需要提取的数据\n- **/sys**[不能动]这是linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统 sysfs\n- **/tmp** 这个目录是用来存放一些临时文件的\n- **/dev**类似于windows的设备管理器，把所有的硬件用文件的形式存储/media[常用]linux系统会自动识别一些设备，例如U盘、光驱等等，当识别后，linux会把识别的设备挂载到这个目录下\n- **/mnt** [常用]系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将外部的存储挂载在/mnt/上，然后进入该目录就可以查看里的内容了。\n- **/opt** 这是给主机额外安装软件所摆放的目录。如安装ORACLE数据库就可放到该目录下。默认为空。\n- **/usr/local** [常用]这是另一个给主机额外安装软件所安装的目录。一般是通过编译源码方式安装的程序\n- **/var** [常用]这个目录中存放着在不断扩充着的东西,习惯将经常被修改的目录放在这个目录下。包括各种日志文件\n- **/selinux** [security-enhanced linux]SELinux是一种安全子系统，它能控制程序只能访问特定文件，有三种工作模式，可以自行设置.\n\n## Vim基本用法\n\nvim是vi的增强版，语法识别高亮显示等。。。\n\nvim <file> 用vim打开文件，没有则默认打开空文件\n\n### vim的三个模式\n\n- 一般模式\n- 输入模式\n- 命令行模式\n\n\n\n进入为一般模式，在一一般模式下按a/A，i/I，o/O按键进入输入模式，按Esc退回一般模式，在正常模式下按:进入命令行模式输入命令按Enter提交。\n\n{% mermaid %}\n\ngraph TD\n    EQ[进入/退出] --vim filename--> Normal[一般模式]\n    Normal --:wq--> EQ\n    Normal --输入i a o --> Input[输入模式]\n    Input --ESC--> Normal\n    Normal --输入 : --> Cmd[命令行模式]\n    Cmd --回车以结束运行--> Normal\n\n{% endmermaid %}\n\n### 一般模式指令\n\n- `yy` 复制当前行（`5yy`复制包括当前往下5行）\n- `p` 粘贴\n- `dd` 删除当前行（`5dd`删除包括当前往下5行）\n- `gg` 光标跳到第一行\n- `G` 光标跳到最后一行\n- `<行号>gg/<行号>G` 光标跳到指定行（例如：`20gg/20G`跳转到行号20）\n- `/<关键词>` 搜索关键词，`n`查找下一个（例如`/hello`）\n\n### 命令行模式指令\n\n- `:h` 查看help.txt\n\n- `:w` 保存写入\n- `:q` 退出\n- `:q!` 强制退出\n- `:wq` 保存写入并退出\n- `:<行号>` 跳转到指定行号（如：`:20` 跳转到行号20）\n- `:set nu` 临时设置行号\n- `:set nonu` 取消行号\n\n### Vim键盘图\n\n![](https://www.runoob.com/wp-content/uploads/2015/10/vi-vim-cheat-sheet-sch.gif)\n\n## 用户管理\n\n### 相关指令（命令）\n`su - <user>` 切换用户\n\n`logout` / `exit` 登出\n\n`id <user>` 查看用户信息\n\n`whoami` 查看当前会话用户\n\n`who am i` 查看登录的用户信息 （第一次会话的）\n\n\n\n`useradd <user>` 创建用户\n\n- `-r` 指定家目录\n- `-g` 添加到指定用户组（不添加将创建与该用户同名的组，并指定该组）\n\n`passwd <user>` 修改用户密码\n\n`userdel <user>` 删除用户\n\n- `-r` 同时删除家目录\n\n`usermod [选项] <user>` 修改用户属性\n\n- `-g` 修改用户组\n- `-d` 修改用户家目录（需要有一定权限）\n\n\n\n`groupadd <group>` 创建用户组\n\n`groupdel <group>` 删除用户组\n\n\n\n### 用户和组相关文件\n\n/etc/passwd文件\n\n- 用户的配置文件，记录用户的各种信息\n- 每行格式： 用户名:口令:用户标识号:组标识号:注释性描述:主目录:Shell登录\n\n/etc/shadow文件\n\n- 口令的配置文件\n- 每行格式： 用户名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志\n\n/etc/group文件\n\n- 组的配置文件，记录Linux包含的组的信息\n- 每行格式： 组名:口令:组标识号:组内用户列表\n\n### 忘记密码解决办法\n\n**基于CentOS 7.9**\n\n1. 重启系统\n2. 在选择界面使用方向上下键选择防止自动选择\n3. 按**e**进入编辑界面\n4. 找到以linux16开头的行，在末尾加入`init=/bin/sh`\n5. Ctrl+X进入单用户模式\n6. 输入：`mount -o remount,rw /`并回车 \n7. 输入：`passwd`并回车\n8. 输入两遍新密码\n9. 输入：`touch /.autorelabel`并回车\n10. 输入：`exec /sbin/init` 并回车\n11. 等待系统重启即可\n\n> 其它操作修改： [Linux系统忘记了root密码怎么办？_Dribblelife的博客-CSDN博客_忘记root密码](https://blog.csdn.net/weixin_38044888/article/details/89915553)\n\n## <span id=\"runLevel\">运行级别</span>\n\n### 基本介绍\n\n运行级别说明：\n\n- 0:关机\n- 1:单用户【找回丢失密码】\n- 2：多用户状态没有网络服务\n- 3：多用户状态有网络服务\n- 4：系统未使用保留给用户\n- 5：图形界面\n- 6：系统重启\n\n常用运行级别是3和5，也可以指定默认运行级别\n\n演示应用实例命令：**`init [0123456]`** \n\n应用案例：通过init 来切换不同的运行级别，比如动 5-3，然后关机。\n\n- `systemctl get-default` 查看默认运行级别\n- `systemctl set-default <级别>` 设置默认运行级别\n  - `multi-user.target` 多用户级别 3\n  - `graphical.target` 图形级别 5\n\n## 帮助指令\n\n- `man <命令或配置文件>` 获得帮助信息（`man ls`查看`ls`命令的帮助信息）\n- `help [命令]` 获取shell内置命令的帮助信息（如`help cd`）\n- `<命令> --help` 查看某命令的帮助信息（如`ls --help`）\n\n## 文件目录指令\n\n`pwd` 显示当前工作目录的绝对路径\n`ls [选项] [目录/文件]` 查看显示目录/文件信息\n\n- `-a` 显示当前目录所有的文件和目录，包括隐藏的\n- `-l` 已列表的方式显示信息（等同于ll）\n- `-i `\n- `-h` 转换大小单位\n\n`cd <dir>` 切换到指定目录\n\n  - `cd ~` 切换到家目录\n  - `cd ..` 返回上一级目录\n\n\n\n`mkdir [选项] <目录>` 创建目录\n\n- `-p` 创建多级目录\n\n`rmdir <目录>` 删除空目录\n`rm [选项] <文件/目录>` 删除目录/文件\n\n- `-r` 递归删除整个目录\n- `-f` 强制删除不提示\n- `-rf` 包含上面两者\n\n`touch <file>` 创建一个空文件\n\n`cp [选项] <source> <dest>` 复制文件/目录到指定目录\n\n- `-r` 递归复制整个目录\n- `\\cp` 强制覆盖不提示\n\nmv 移动文件与目录或重命名\n\n- `mv <oldName> <newName>` 重命名\n- `mv <file/dir> <path>` 移动文件/目录\n\n\n\n`cat [选项]` 查看文件内容\n\n- `-n` 显示行号\n- `cat [选项] <file> | more `\n\n\n\nmore 基于VI编辑器的文本过滤器，以全屏幕的方式按页显示\n\n- Space  翻动下一页\n- Enter  翻动下一行\n- q 退出\n- Ctrl+F 翻动下一屏\n- Ctrl+B 翻动上一屏\n- = 输出当前行的行号\n- :f 输出文件名和当前行的行号\n\nless 分屏查看文件内容，与more类似但更强大，按需加载\n\n- Space  翻动下一页\n- PageDown 翻动下一页\n- PageUp 翻动上一页\n- /<keyword> 向下搜寻。 n：下一个 N：上一个\n- ?<keyword> 向上搜寻。 n：下一个 N：上一个\n- q 退出\n\n\n\n`echo [选项] <content>`  输出内容到控制台\n\n- 如 `echo $HOSTNAME` 输出主机名\n- 如 `echo $PATH` 输出环境变量\n\n`head [选项] <file>` 显示文件的头部内容，默认前十行\n\n- `-n <lines>` 显示前多少行\n- `-c  <bytes>` 显示前多少字节\n\n`tail [选项] <file>` 显示文件的尾部内容，默认后十行\n\n- `-n <lines>` 显示后多少行\n- `-c  <bytes>` 显示后多少字节\n- `-f` 实时监控文件变化\n\n\n\n'>' 输出重定向（覆盖）\n\n'>>' 追加\n\n- `ls -l > 文件` 列表的内容覆盖到文件\n- `ls -al >> 文件` 列表的内容追加到文件\n- `cat 文件1 > 文件2` 将文件1的内容覆盖到文件2\n- `echo \"内容\"  >> 文件` 追加内容到文件\n\n\n\nIn指令：软链接也称为符号链接，类似于windows里的快捷方式，主要存放了链接其他文件的路径\n\n- `ln -s <原文件/目录> <软链接名>` 给原文件/目录创建一个软链接（pwd查看仍在原文件/目录）\n\n\n\n`history [数量]` 查看已经执行过的历史命令，无参默认显示全部\n\n- `!<编号>` 执行历史命令中编号为<编号>的命令（如!5 执行编号为5的命令）\n\n## 时间日期指令\n\n`date` 显示当前时间\n`date +%Y` 显示当前年份\n`date +%m` 显示当前月份\n`date +%d` 显示当前是哪一天\n`date \"+%Y-%m-%d %H:%M:%S\"` 显示年月日时分秒\n`date -s <字符串时间>` 设置系统当前时间\n\n\n\n`cal [选项]` 显示当前日历，无参默认显示当前时间日历\n\n- `cal 2023` 显示2023年日历\n\n## 搜索查找指令\n\n`find [范围] [选项]` 从指定目录向下递归遍历其各个子目录查找\n\n- `-name <name>` 按照指定的文件名查找\n- `-user <user>` 查找属于指定用户名的所有文件\n- `-size <size> `按照指定的文件大小查找文件（单位K，M，G）\n  - `find / -size +200M `查找/下大于200M的文件，-200M表示小于200M的文件\n\n`locate <file>` 可以快速定位文件路径。\n\n- locate指令利用事先建立的系统中所有文件名称及路径的locate数据库实现快速定位给定的文件。\n- locate指令无需遍历整个文件系统,查询速度较快。\n- 为了保证查询结果的准确度，管理员必须定期更新locate时刻\n- `updatedb` 更新数据库\n\n`which <cmd>` 查询某个指令在哪个目录下\n\n\n\n`grep [选项] <内容> <源文件>` 过滤查找\n\n- `-n` 显示匹配行及行号\n- `-i` 忽略字母大小写\n\n\n\n`|`管道符 ，将前一个命令查询到的内容交给下一个命令\n\n- `cat a.txt | grep \"hello\"`    cat查询到的内容交给grep进行过滤查找\n\n## 压缩和解压\n\n`gzip <file>` 只能将文件压缩成.gz文件\n\n`gunzip <file.gz>` 解压.gz文件\n\n\n\n`zip [选项] <name.zip> <file/dir>` 压缩成name.zip文件\n\n- `-r` 递归压缩，即压缩目录\n\n`unzip [选项] <file.zip>` 解压\n\n- `-d <dir>` 指定解压后存放目录\n\n\n\n`tar [选项]` 打包、压缩或解压\n\n- `-c` 产生.tar打包文件\n- `-v` 显示详细信息\n- `-f` 指定压缩后的文件名\n- `-z` 通过gzip指令处理压缩解压\n- `-j` 通过bzip2指令处理压缩解压\n- `-x` 解包.tar文件\n- `-C` 指定解压目录\n- 常见用法\n  - `tar -czvf <xxx.tar.gz> <file>...` 压缩成.tar.gz\n  - `tar -xzvf <xxx.tar.gz>` 解压\n  - `tar -tzvf <xxx.tar.gz>` 列出压缩文件内容\n\n> [Linux tar 命令 |  菜鸟教程](https://www.runoob.com/linux/linux-comm-tar.html)\n\n## Linux组(权限)\n\n### 基本内容\n\n在linux中的每个用户必须属于一个组，不能独立于组外。在linux中每个文档/文件有所有者、所属组、其它组的概念。\n\n\n\n`ls -ahl`显示格式解释如下：\n\n| 文档/文件属性 | 链接数 | 所有者  | 所属组  | 大小 |   修改时间    |\n| :-----------: | :----: | :-----: | :-----: | :--: | :-----------: |\n|  drwx------.  |   16   | wshape1 | wshape1 | 4.0K | 1月  25 14:17 |\n|  -rw-r--r--.  |   1    |  root   |  root   | 15K  | 1月  25 17:03 |\n\n![](https://www.runoob.com/wp-content/uploads/2014/06/file-llls22.jpg)\n\n文档属性：\n\n- 第一位：表示文档类型\n  - d 目录\n  - -文件\n  - l 链接文档\n  - b 装置文件里面的可供储存的接口设备(可随机存取装置)（块文件）\n  - c 装置文件里面的串行端口设备，例如键盘、鼠标(一次性读取装置)（字符设备）\n- 第2到4位：所有者权限\n- 第3到5位：所属组权限\n- 第6到8位：其他组权限\n\n![](https://www.runoob.com/wp-content/uploads/2014/06/363003_1227493859FdXT.png)\n\n**rwx作用到文件**\n\n1. [**r**]代表可读(read):可以读取,查看字\n2. [**w**]代表可写(write)：可以修改，但是不代表可以删除该文件,删除一个文件的前提条件是对该文件所在的目录有写权限，才能删除该文件.\n3. [**x**]代表可执行(execute):可以被执行\n\n**rwx作用到目录**\n\n1. [**r**]代表可读(read)：可以读取，Is查看目录内容 （但是不能进入目录）\n2. [**w**]代表可写(write)： 可以修改,对目录内创建+删除+重命名目录\n3. [**x**]代表可执行(execute)：可以进入该目录 （但是不能查看目录内容）\n\n\n\n### 常用指令\n\n`chown [选项] <user> <file/dir>` 修改文件/目录所有者\n\n- `chown [选项] <newOwner>:<newGroup> <file/dir>` 同时修改所有者与所属组\n\n`chgrp [选项] <group> <file/dir>` 修改文件/目录所在组 \n\n`chmod [选项] <权限> <file/dir>` 修改文件/目录权限\n\n- rwx方式变更权限u：所有者，g：所属组，o：其它组，a：所有人（u g o的总和）\n  - 例：`chmod u=rwx, g=rx, o=x <文件/目录>` 给u g o分别赋予rwx rx x权限\n  - 例：`chmod o+w <文件/目录>` 给o增加w权限\n  - 例：`chmod a-x <文件/目录>` 给a移除x权限\n- 数字方式变更权限r=4 w=2 x=1，rwx=4+2+1=7\n  - 例：`chmod 751<文件/目录>` 等同于u=rwx, g=rx, o=x\n\n\n\n以上三个指令共有选项：\n\n- -R 递归修改目录内内容权限\n\n\n\n修改权限后用户仍无法控制则可能需要重新登陆\n\n## 定时任务调度\n\n**任务调度**：是指系统在某个时间执行的特定的命令或程序。\n\n**任务调度分类**:\n\n1. 系统工作:有些重要的工作必须周而复始地执行。如病毒扫描等\n2. 个别用户工作：个别用户可能希望执行某些程序，比如对mysql数据库的备份\n\n### crond任务调度\n\n>  [Linux crontab 命令 | 菜鸟教程](https://www.runoob.com/linux/linux-comm-crontab.html)\n\n`crontab [选项]`\n\n- `-e` 编辑定时任务\n- `-l` 查询定时任务\n- `-r` 删除当前用户所有的定时任务\n\nservice crond restart 重启crond\n\n\n\n**调度文件：**\n\n- 文件内容格式：`f1 f2 f3 f4 f5 program`  f1--5为时间格式program为执行程序\n\n- 时间占位符（时间格式）\n\n  ```pseudocode\n  *    *    *    *    *\n  -    -    -    -    -\n  |    |    |    |    |\n  |    |    |    |    +----- 星期中星期几 (0 - 6) (星期天 为0)\n  |    |    |    +---------- 月份 (1 - 12) \n  |    |    +--------------- 一个月中的第几天 (1 - 31)\n  |    +-------------------- 小时 (0 - 23)\n  +------------------------- 分钟 (0 - 59)\n  ```\n\n- 时间格式特殊符号\n  \n  \n  | 特殊符号 | 含义                                                         |\n  | -------- | ------------------------------------------------------------ |\n  | *        | 代表任何时间。比如第一个“*”就代表一小时中每分钟都执行一次的意思。 |\n  | ,        | 代表不连续的时间。比如“0 8,12,16 * * * 命令”，就代表在每天的8点0分，12点0分，16点0分都执行一次命令 |\n  | -        | 代表连续的时间范围。比如\"05 * * 1-6命令\" ,代表在周一到周六的凌晨5点0分执行命令 |\n  | */n      | 代表每隔多久执行一次。比如“*/10 * * * * 命令”，代表每隔10分钟就执行一遍命令 |\n\n\n\n### at定时任务\n\n1. at命令是一次性定时计划任务,at的守护进程atd会以后台模式运行,检查作业队列来运行。\n2. 默认情况下，atd守护进程每60秒检查作业队列，有作业时，会检查作业运行时间，如果时间与当前时间匹配，则运行此作业。\n3. at命令是一次性定时计划任务，执行完一个任务后不再执行此任务了。\n4. 在使用at命令的时候,一定要保证atd进程的启动,可以使用相关指令（`ps -ef | grep atd`）来查看。\n\n\n\n`at [选项] [时间]` 设置定时任务 （Ctrl+D结束命令输入）\n\n- `-m` 当指定的任务被完成后，将给用户发送邮件，即使没有标准输出\n- `-I` 显示待执行任务的列表 (同atq命令)\n- `-d` 删除指定的待执行任务（同atrm命令）\n- `-v` 显示任务将被执行的时间\n- `-c` 打印任务的内容到标准输出\n- `-V` 显示版本信息\n- `-q <队列>` 使用指定的队列\n- `-f <文件>` 从指定文件读入任务而不是从标准输入读入\n- `-t <时间参数>` 以时间参数的形式提交要运行的任务\n\n时间表达式：\n\n- YYMMDDhhmm[.ss]（缩写年、月、日、小时、分钟[秒]）\n- CCYYMMDDhhmm[.ss]（完整年、月、日、小时、分钟和[秒]）\n- now\n- midnight\n- noon\n- teatime (4:00PM)\n- tomorrow\n- AM\n- PM\n- 可以添加一个+使它们相对于某个时间，下面是可用单位：\n  - minutes\n  - hours\n  - days\n  - weeks\n  - months\n  - years\n\n```pseudocode\n$ echo \"rsync -av /home/tux me@myserver:/home/tux/\" | at 3:30 AM tomorrow\n$ echo \"/opt/batch.sh ~/Pictures\" | at 3:30 AM 08/01/2022\n$ echo \"echo hello\" | at now + 3 days\n```\n\n>  [Linux at命令详解 - 许良Linux](https://www.cnblogs.com/yychuyu/p/15483186.html)\n\n## 磁盘管理\n\n\n\n### 磁盘分区\n\n**原理介绍:**\n\n1. Linux来说无论有几个分区，分给哪一目录使用，它归根结底就只有一个根目录，一个独立且唯一的文件结构，Linux中每个分区都是用来组成整个文件系统的一部分。\n2. Linux采用了一种叫“载入”的处理方法,它的整个文件系统中包含了一整套的文件和目录，且将一个分区和一个目录联系起来。这时要载入的一个分区将使它的存储空间在一个目录下获得。\n\n**硬盘说明：**\n\n1. Linux硬盘分IDE硬盘和SCSI硬盘，目前基本上是SCSI硬盘\n2. 对于IDE硬盘,驱动器标识符为\"hdx~\",其中\"hd\"表明分区所在设备的类型,这里是指IDE硬盘了。\"x”为盘号（a为基本盘，b为基本从属盘，c为辅助主盘，d为辅助从属盘），\"~”代表分区前四个分区用数字1到4表示，它们是主分区或扩展分区，从5开始就是逻辑分区。例，hda3表示为第一个IDE硬盘上的第三个主分区或扩展分区,hdb2表示为第二个IDE硬盘上的第二个主分区或扩展分区。\n3. 对于SCSI硬盘则标识为“sdx~”,SCSI硬盘是用“sd\"来表示分区所在设备的类型的，其余则和IDE硬盘的表示方法一样。\n\n\n\n**查看所有设备挂载情况**\n\n- `lsblk`\n\n- `lsblk -f`\n\n\n\n**分区命令：**\n\n- `fdisk /dev/sdx `\n- 开始对/sdx分区\n  - m 显示命令列表\n  - p 显示磁盘分区\n  - n 新增分区\n  - d 删除分区\n  - w 写入并退出\n\n**格式化磁盘：**\n\n`mkfs -t <分区类型> /dev/sdx~`\n\n- 分区类型：ext2、ext3、ext4、reiserfs、nfs、vfat\n\n**挂载分区：**\n\n`mount <设备> <目录>`\n\n- `mount /dev/sdx~ <dir>`\n\n- **重启系统后失效**\n\n- **永久挂载分区：**\n\n  - 修改/etc/fstab \n\n  - 添加行，行格式：`UUID或者设备名称 挂载目录 分区类型 文件系统的参数 能否被dump备份命令作用 是否检测扇区 `\n    如：`/dev/sdx~ /newdisk ext4 defaults 0 0 `\n\n  - 执行mount -a 或重启系统\n\n  - > [/etc/fstab文件的详解_韩帅平的博客-CSDN博客_/etc/fstab](https://blog.csdn.net/youmatterhsp/article/details/83933158)\n\n**卸载分区：**\n\n`umount <设备>`\n\n`umount <被挂载目录>`\n\n### 磁盘使用情况\n\n`df -Th` 查看整体磁盘使用情况\n\n`du [选项] [dir]` 查看指定目录的磁盘使用情况，默认为当前目录\n\n- `-s` 指定目录占用大小汇总\n\n- `-h` 带计量单位\n\n- `-a` 含文件\n\n- `--max-depth=1` 子目录深度\n\n- `-c` 列出明细的同时，增加汇总值\n\n- > [Linux 磁盘管理 | 菜鸟教程 (runoob.com)](https://www.runoob.com/linux/linux-filesystem.html)\n\n### 实用指令\n\n1. 统计/opt文件夹下文件的个数\n   `ls -l /opt | grep \"^-\" | wc -l`\n2. 统计/opt文件夹下目录的个数\n   `ls -l /opt | grep \"^d\" | wc -l`\n3. 统计/opt文件夹下文件的个数，包括子文件夹里的\n   `ls -lR /opt | grep \"^-\" | wc -l`\n4. 统计/opt文件夹下目录的个数，包括子文件夹里的\n   `ls -lR /opt | grep \"^d\" | wc -l`\n5. 以树状显示目录结构tree目录，可能需要执行`yum install tree`安装\n\n> [Linux wc命令 | 菜鸟教程 (runoob.com)](https://www.runoob.com/linux/linux-comm-wc.html)\n\n\n\n## 网络配置\n\nNAT(Network Address Translation)网络配置\n\n{% mermaid %}\n\nflowchart LR\n\tsubgraph 电脑Windows\n\t\tlinux(Linux虚拟\\n192.168.245.128) --> vmnet(VMnet8\\n192.168.245.1)\n        vmnet --> linux\n        wk([无线网卡\\n192.168.31.122])\n        vmnet --> wk\n\tend\n\tsubgraph 局域网\n\t\twk --> wg(网关)\n\tend\n\twg --> three[互联网\\nbaidu.com\\n...]\n\n{% endmermaid %}\n\n`ifconfig` 查看网络配置\n\n`ping <ip>` 测试当前主机是否可以于目标ip进行通讯\n\n\n\n### IP配置\n\n- 自动获取：\n\n  - 登陆后，通过界面的来设置自动获取ip\n  - 特点：linux启动后会自动获取IP\n  - 缺点是每次自动获取的ip地址可能不一样。\n\n- 手动配置：\n\n  - 图形化：网络设置里配置\n\n  - 直接修改配置文件来指定IP并可以连接到外网(程序员推荐)\n    - 编辑/etc/sysconfig/network-scripts/ifcfg-ens33（如修改为192.168.245.2）\n      - 修改IPV4配置方式`BOOTPROTO=\"static\"`\n      - 修改IP地址`IPADDR=192.168.245.128`\n      - 修改网关`GATEWAY=192.168.245.2`\n      - 修改DNS`DNS=192.168.245.2`\n      - 虚拟机的记得要配置虚拟机网络相关配置\n      - `service network restart`或重启系统\n\n### 主机名与hosts映射\n\n**查看主机名：**\n\n- `hostname`\n\n**修改主机名：**\n\n- 修改文件/etc/hostname\n- 重启系统\n\n**修改hosts映射：**\n\n- 编辑配置文件/etc/hosts\n- 行格式：`ip  域名(主机名)`\n\n## 进程管理\n\n在Linux中，每个执行的程序都称为一个进程。每一个进程都分配一个ID号(pid,进程号)。\n\n每个进程都可能以两种方式存在的。前台与后台，所谓前台进程就是用户目前的屏幕上可以进行操作的。后台进程则是实际在操作，但由于屏幕上无法看到的进程，通常使用后台方式执行。\n\n\n\n`ps [选项]` 显示目前系统正在运行的程序\n\n- `-a ` 显示当前终端的所有进程信息\n- `-u` 以用户的格式显示进程信息\n- `-x` 显示后台进程运行的参数\n- `-w` 不限制输出宽度\n- `-e` 显示所有进程\n- `-f` 全格式输出，包括命令\n- 寻找指定进程：`ps -ef | grep <关键词>`\n- `ps -aux`输出格式：`USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND`\n  - USER: 进程执行用户\n  - PID: 进程号\n  - %CPU: 占用的 CPU 使用率\n  - %MEM: 占用的物理内存使用率\n  - VSZ: 占用的虚拟内存大小 (KB)\n  - RSS: 占用的物理内存大小 (KB)\n  - TTY: 终端的次要装置号码 (minor device number of tty)\n  - STAT: 该行程的状态:\n    - D: 无法中断的休眠状态 (通常 IO 的进程)\n    - R: 正在执行中 running\n    - S: 静止状态 sleep\n    - T: 暂停执行\n    - Z: 不存在但暂时无法消除（僵尸进程）\n    - W: 没有足够的内存分页可分配\n    - <: 高优先序的进程\n    - N: 低优先序的进程\n    - L: 有内存分页分配并锁在内存内 (实时系统或捱A I/O)\n  - START: 进程开始时间\n  - TIME: 执行的时间\n  - COMMAND:所执行的指令（过长会被截断）\n\n**父子进程**\n\n- ps -ef 查看 \n- PPID表示父进程pid\n\n**终止进程**\n\n- `kill [选项] <pid>` 终止进程\n  - `-9` 强制终止进程\n- `killall <程序名>` 通过进程名称杀死进程，也支持通配符，这在系统因负载过大而变得很慢时很有用\n\n**查看进程树**\n\n- `pstree [选项]` 查看进程树\n  - `-p` 显示进程的PID\n  - `-u` 显示进程的所属用户\n\n### 动态进程管理\n\n`top [选项]` 实时更新显示进程\n\n- `-d <秒>` 指定更新间隔\n- `-i` 不显示任何闲置或者僵尸进程\n- `-p <pid>` 监控指定pid的进程 \n- `-n` 更新几次后退出\n\n显示头：\n\n```pseudocode\ntop - 11:13:24 up 37 min,  1 user,  load average: 0.00, 0.01, 0.03\nTasks: 224 total,   1 running, 223 sleeping,   0 stopped,   0 zombie\n%Cpu(s):  0.0 us,  0.1 sy,  0.0 ni, 99.9 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st\nKiB Mem :  2027680 total,  1168104 free,   478228 used,   381348 buff/cache\nKiB Swap:  2097148 total,  2097148 free,        0 used.  1389524 avail Mem \n\n   PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND\n```\n\n**交互操作：**\n\n- `P`以%CPU排序，默认就是此项\n- `M`以%MEM排序\n- `N`以PID排序\n- `u` 查看指定用户的进程\n- `k` 删除指定PID的进程\n- `q` 退出\n\n### 服务管理\n\n服务(service)本质就是进程，但是是运行在后台的，通常都会监听某个端口，等待其它程序的请求，比如（mysqld，sshd 防火墙等），因此我们又称为守护进程，是Linux中非常重要的知识点。\n\n#### service管理指令\n\n- `service <服务名> <start | stop | restart | reload | status>`\n\nservice指令管理的服务在/etc/init.d/查看（`ll /etc/init.d/`）\n\n**查看系统服务**\n\n- `setup`\n\n**开机流程：**\n\n{% mermaid %}\n\ngraph LR\n    开机 ==> BIOS ==> /boot ==> systemd进程 ==> 运行级别 ==> 运行级别对应的服务\n\n{% endmermaid %}\n\n跳转查看[运行级别](#runLevel)解释\n\n\n\n#### chkconfig指令  \n\n管理服务在各个运行级别的自启动\n\nchkconfig 指令管理的服务在/etc/init.d/ 查看\n\n基本用法：\n\n- `chkconfig --list` 查看服务\n- `chkconfig <服务名> --list` 查看某个服务\n- `chkconfig --level <运行级别> <服务名> <on | off> ` 设置\n\n**重启系统生效**\n\n#### systemctl管理指令\n\nsystemctl指令管理的服务在**/usr/lib/systemd/system/**查看(`ll /usr/lib/systemd/system/`)\n\nsystemctl简化了运行级别，只有3和5\n\n**基本用法：**\n\n- `systemctl <start | stop | restart | status> <服务名>` 开启/关闭/重启/查询 服务\n- `systemctl list-unit-files` 查看服务开机启动状态(是否开机自启)\n- `systemctl <enable | disable> <服务名>` 开启/关闭服务开机自启动\n- `systemctl is-enabled <服务名>`查询某个服务是否是自启动的\n\n#### <span id=\"firewall\">防火墙端口指令</span>\n\n`firewall-cmd --permanent --add-port=端口号/协议` 打开端口\n\n`firewall-cmd --permanent --remove-port=端口号/协议` 关闭端口\n\n`firewall-cmd --reload` 重新载入,才能生效\n\n`firewall-cmd --query-port=端口/协议 ` 查询端口是否开放\n\n### 系统网络情况netstat\n\n`netstat [选项]`\n\n- `-an` 按一定顺序输出排列\n- `-p` 显示哪个进程在调用\n\n## rpm和yum包管理\n\n### RPM\n\n`rpm [选项]` rpm包管理指令\n\n- `-qa` 查询所有已安装的rpm软件包\n- `-q <name>` 查询指定的软件包是否安装\n- `-qi <name>` 查询指定软件包的信息\n- `-ql <name>` 查询指定软件包的文件\n- `-qf <文件全路径名>` 查询文件所属的软件包\n- `-e <name>` 删除指定软件包（`--nodeps` 强制删除）\n- `-ivh <file>` 安装软件包（-i安装，-v提示，-h进度条）\n\n### YUM\n\nYum是一个Shell前端软件包管理器。基于RPM包管理,能够从指定的服务器自动下载RPM包并且安装，**可以自动处理依赖性关系**，并且一次安装所有依赖的软件包。\n\n`yum [选项]` yum包管理指令\n\n- `list` 查看服务器支持的包列表（可以使用grep过滤）\n- `install <name>` 下载安装指定软件包\n- `check-update`  检查是否有可用的软件包更新\n- `update [name]` 更新系统中的一个或多个软件包\n\n[linux yum 命令 | 菜鸟教程 (runoob.com)](https://www.runoob.com/linux/linux-yum.html)\n\n## 搭建JavaEE环境\n\n### 安装JDK\n\n[Java Downloads | Oracle 中国](https://www.oracle.com/cn/java/technologies/downloads/)\n\n1. yum安装\n   - `yum list java*` 查看服务器jdk版本列表\n   - `yum install java-x.x.x-openjdk` 安装指定版本\n2. rpm安装\n   - 下载指定版本JDK的rpm安装包\n   - `rpm -ivh <file>` 等待安装完成即可\n   - 默认安装在/usr/lib/jvm\n3. 压缩包安装(以JDK17为例)\n   - 下载安装包到/opt （其它目录也行），并进入/opt\n   - 解压 `tar -zxvf jdk-17_linux-x64_bin.tar.gz`\n   - 创建文件夹`mkdir /usr/local/java`\n   - 移动jdk `mv jdk-17.0.6/ /usr/local/java/ `\n   - 配置环境变量 `vim /etc/profile`在文件末尾添加以下内容：\n     - `export JAVA_HOME=/usr/local/java/jdk-17.0.6`\n     - `export PATH=$JAVA_HOME/bin:$PATH`\n   - 执行`source /etc/profile` 使配置生效，或者重启系统\n\n### 安装Tomcat\n\n[Apache Tomcat® - Apache Tomcat 9 Software Downloads](https://tomcat.apache.org/download-90.cgi)\n\n1. yum安装\n   - `yum install tomcat`\n   - `systemctl <start | stop> tomcat.service` 启动/关闭\n2. 压缩包安装（以Tomcat9为例）\n   - 下载Tomcat9至/opt目录（可以是其它目录）\n   - 执行`tar -zxvf apache-tomcat-9.0.71.tar.gz `解压\n   - 进入/apache-tomcat-9.0.71/bin `cd apache-tomcat-9.0.71/bin/`\n   - 执行`./startup.sh`启动Tomcat\n   - 注意Linux防火墙是否拦截8080端口（[指令设置](#firewall)）\n   - 如需设置环境变量，方法如上\n   - 执行`./shutdown.sh`关闭Tomcat\n\n### 安装MySql\n\n[MySQL :: Download MySQL Community Server](https://dev.mysql.com/downloads/mysql/)\n\n1. rpm安装（以8.0为例）\n   - 下载rpm安装包到指定文件夹 （bundle后缀的文件）\n   - 查询是否有mariadb，如有则卸载\n     - `rpm -qa | grep mariadb` 查询\n     - `rpm -e --nodeps mariadb-libs`卸载\n   - 解压bundle `tar -xvf  mysql-8.0.32-1.el7.x86_64.rpm-bundle.tar`\n   - 依次安装：\n     - *`rpm -ivh mysql-community-common-8.0.32-1.el7.x86_64.rpm`\n     - `rpm -ivh mysql-community-client-plugins-8.0.32-1.el7.x86_64.rpm`\n     - *`rpm -ivh mysql-community-libs-8.0.32-1.el7.x86_64.rpm`\n     - *`rpm -ivh mysql-community-client-8.0.32-1.el7.x86_64.rpm`\n     - `rpm -ivh mysql-community-icu-data-files-8.0.32-1.el7.x86_64.rpm`\n     - *`rpm -ivh mysql-community-server-8.0.32-1.el7.x86_64.rpm`\n   - 初始root密码查看`grep password /var/log/mysqld.log`\n   - 启动MySql服务 `systemctl start mysqld.service`\n   - 进入MySql并修改初始密码\n     - `mysql -u root -p`\n     - `ALTER USER root@localhost IDENTIFIED BY '密码';`\n\n## Shell入门\n\n","tags":["Linux","笔记"],"categories":["Linux"]},{"title":"快速幂算法(例:a^b mod p)","url":"/2022/07/15/fast_power/","content":"\n# 介绍\n\n**快速幂**（**Exponentiation by squaring**，平方求幂）是一种简单而有效的小算法，它可以以O(log n)的时间复杂度计算乘方。快速幂不仅本身非常常见，而且后续很多算法也都会用到快速幂。\n\n### 为什么要使用快速幂？\n\n比如要计算以下式子：\n$$\n9^{10}=?\n$$\n传统算法是\n$$\n9^{10} = 9*9*9*9*9*9*9*9*9*9\n$$\n计算机要通过**9次**计算才能得出答案。而快速幂的方法就是通过平方来减少计算次数：\n$$\n9^{10}=(9*9)^{5}=(81*81)^{2}*81\n$$\n这样子就只需要**4次**。\n\n这样的时间复杂度是**O(log n)**，当次方很大时可以节省很多时间。\n\n### 算法实现\n\n##### 非递归版\n\n```pseudocode\nfast_power(a, b)\n\tans = 1\n    while(b)\n        if b % 2 == 1\t//当幂为奇数时\n            ans *= a\n            b -= 1\n        else\n            a *= a\n            b /= 2\n    return ans\n```\n\n在b % 2 == 1运行完成后，b必定是偶数，接下来会再次进行while循环进入到else里面，其实我们可以简化成一次循环，如下：\n\n```pseudocode\nfast_power(a, b)\n\tans = 1\n    while(b)\n        if b % 2 == 1\n            ans *= a\n        a *= a\n        b /= 2\n    return ans\n```\n\n##### 递归版（慎用）\n\n```pseudocode\nfast_power(a, b)\n\tif b <= 0\n    \treturn 1\n    if b % 2 == 1\t//当幂为奇数时\n    \tans = fast_power(a, b - 1) * a\n    else \n    \tans = fast_power(a * a, b / 2)\n    return ans\n```\n\n以上都要**注意变量a, b, ans的范围**。\n\n### 例题a^b\n\n\n\n题目：[牛客网](https://ac.nowcoder.com/acm/contest/996/A \"a^b\")\n$$\n求 a 的 b 次方对 p 取模的值，其中 0≤a,b,p≤10^9，p>0\n$$\n**输入描述：**\n\n> 三个用空格隔开的整数a,b和p。\n\n**输出描述：**\n\n> 一个整数，表示a^b mod p的值。\n\n##### **思路：**\n\n1. 最直接的思路就是算出a^b的值之后再模p，不管是否上述快速幂的方法，都存在一个很明显问题是 a^b 的范围大至10的9次方的10的9次方，**远超过了long long的范围**。\n\n2. 利用**快速幂+取模运算的性质**，可以快速的同时不会让数值超过范围，性质**(a * b) % p = (a % p * b % p) % p** \n\n   于是可以得到以下代码：\n\n   ```c++\n   typedef long long ll;\n   ll fast_power(ll a, ll b, ll p) {\n   \tll ans = 1;\n       a %= p;\n       while(b) {\n           if(b % 2 == 1) {\n               ans = (ans * a) % p;\n           a = (a * a) % p;\n           b /= 2;\n       }\n       return ans % p;\n   }\n   ```\n\n3. 其实还可以使用**位运算**，提升运行的速度，代码如下：\n\n   ```c++\n   typedef long long ll;\n   ll fast_power(ll a, ll b, ll p) {\n   \tll ans = 1;\n       a %= p;\n       while(b) {\n           if(b & 1) {\t\t// 如7二进制为0000 0111，1二进制为0000 0001，则7&1 = 0000 0001 = 1\n               ans = (ans * a) % p;\n           a = (a * a) % p;\n           b >>= 1;\t\t// 7二进制为0000 0111，向右位移一位为 0000 0011 = 3 （不足补0）\n       }\n       return ans % p;\n   }\n   ```\n\n   常见的位运算符有 与& 或| 右移>> 左移<< 异或^\n\n##### **最终代码：**\n\n```c++\n#include <iostream>\n\nusing namespace std;\n\ntypedef long long ll;\n\nll fast_power(ll a, ll b, ll p) {\n    a %= p;\n    ll ans = 1;\n    while(b) {\n        if(b & 1)\n            ans = (ans * a) % p;\n        a = (a * a) % p;\n        b >>= 1;\n    }\n    return ans % p;\n}\n\nint main() {\n    \n    ll a, b, p;\n    \n    cin >> a >> b >> p;\n    \n    cout << fast_power(a, b, p);\n    \n    return 0;\n}\n```\n\n\n\n> 参考资料：\n>\n> [1] [Pecco : 算法学习笔记(4)：快速幂](https://zhuanlan.zhihu.com/p/95902286)\n>\n> [2] [芸学习 : 【C++/算法】快速幂算法详解](https://www.bilibili.com/video/BV12r4y1w7tx?spm_id_from=333.337.search-card.all.click&vd_source=c155e4a52de51664d15aaf241c4a7656)\n","tags":["基本算法","快速幂","取模运算","位运算"],"categories":["基本算法"]},{"title":"最小生成树(Minimum Spanning Tree)","url":"/2022/02/23/minimum_spanning_tree/","content":"\n## 前言\n\n例题：[AizuOJ ALDS_12A](https://onlinejudge.u-aizu.ac.jp/courses/lesson/1/ALDS1/12/ALDS1_12_A)  &  [AizuOJ GRL_2_A](https://onlinejudge.u-aizu.ac.jp/courses/library/5/GRL/2/GRL_2_A )\n\n本题可以使用**普里姆(Prim)算法**或**克鲁斯卡尔(Kruskal)算法**进行实现。\n\n两种算法的简单比较：\n\n|         |      时间复杂度       | 最适合 |\n| :-----: | :-------------------: | :----: |\n|  Prim   |        O(n^2)         | 稠密图 |\n| Kruskal | O(E * log E)，E为边数 | 稀疏图 |\n\n视频：[最小生成树(Kruskal(克鲁斯卡尔)和Prim(普里姆))算法动画演示](https://www.bilibili.com/video/BV1Eb41177d1 \"WAY_zhong - BiliBili\")\n\n以下代码是 [AizuOJ GRL_2_A](https://onlinejudge.u-aizu.ac.jp/courses/library/5/GRL/2/GRL_2_A ) 的解法。\n\n## 普里姆算法\n\n代码如下：\n\n```c++\n#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <limits.h>\n\nusing namespace std;\n\n#define MAX 10000\n\ntypedef pair<int, int> PII;\n\nvector<PII> D[MAX]; \t//PII(id, w)\nint sum = 0, d[MAX];\n//int p[MAX];\nbool seen[MAX] = {false};\n\nint main() {\n\tint V, E, s, t, w;\n\n\tscanf(\"%d %d\", &V, &E);\n\n\tfor (int i = 0; i < V; i++) {\n\t\td[i] = INT_MAX;\n\t}\n\n\tfor (int i = 0; i < E; i++) {\n\t\tscanf(\"%d %d %d\", &s, &t, &w);\n\t\tD[s].push_back(PII(t, w));\n\t\tD[t].push_back(PII(s, w));\n\t}\n\n\tint ct = 0;\n\ts = 0;\n\tseen[0] = true;\n\n\twhile (ct < V - 1) {\n\t\tfor (int i = 0; i < D[s].size(); i++) {\n\t\t\tt = D[s][i].first;\n\t\t\tw = D[s][i].second;\n\t\t\tif (!seen[t] && d[t] > w) {\n\t\t\t\td[t] = w;\n//\t\t\t\tp[t] = u;\n\t\t\t}\n\t\t}\n\n\t\tint min = 0;\n\t\tfor (int i = 0; i < V; i++)\n\t\t\tif (!seen[i] && d[i] < d[min])\n\t\t\t\tmin = i;\n\n\t\tseen[min] = true;\n\t\ts = min;\n\t\tsum += d[min];\n\t\tct++;\n\t}\n\n\tprintf(\"%d\\n\", sum);\n\n\treturn 0;\n}\n```\n\n运行结果：\n\n| Lang | Status | Judge |  Time  | Memory | Code |\n| :--: | :----: | :---: | :----: | :----: | :--: |\n| C++  |   AC   | 20/20 | 00.22s | 6024KB | 861B |\n\n## 克鲁斯卡尔算法\n\n代码如下：\n\n```c++\n#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <limits.h>\n\nusing namespace std;\n\n#define MAX 10000\n\ntypedef struct {\n\tint v1, v2, w;\n} Info;\n\nvector<Info> D;\nint p[MAX], h[MAX], d[MAX];\n\nbool cmp(const Info a, const Info b) {\n\treturn a.w < b.w;\n}\n\nint find(int a) {\n\tif (p[a] != a) {\n\t\tp[a] = find(p[a]);\n\t}\n\treturn p[a];\n}\n\nvoid unite(int x, int y) {\n\tint rX = find(x);\n\tint rY = find(y);\n\n\tif (rX != rY) {\n\t\tif (h[rX] > h[rY])\n\t\t\tp[rY] = rX;\n\t\telse {\n\t\t\tp[rX] = rY;\n\t\t\tif (h[rX] == h[rY])\n\t\t\t\th[rY]++;\n\t\t}\n\t}\n}\n\n\nint main() {\n\tint V, E, sum = 0;\n\tint s, t, w;\n\n\tscanf(\"%d %d\", &V, &E);\n\n\tfor (int i = 0; i < V; i++) {\n\t\td[i] = INT_MAX;\n\t\tp[i] = i;\n\t\th[i] = 0;\n\t}\n\n\tfor (int i = 0; i < E; i++) {\n\t\tscanf(\"%d %d %d\", &s, &t, &w);\n\t\tInfo tmp = {s, t, w};\n\t\tD.push_back(tmp);\n\t}\n\n\tsort(D.begin(), D.end(), cmp);\n\n\tfor (int i = 0; i < E; i++) {\n\t\tif (find(D[i].v1) != find(D[i].v2)) {\n\t\t\tunite(D[i].v1, D[i].v2);\n\t\t\tsum += D[i].w;\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", sum);\n\n\treturn 0;\n}\n```\n\n运行结果：\n\n| Lang | Status | Judge |  Time  | Memory | Code  |\n| :--: | :----: | :---: | :----: | :----: | :---: |\n| C++  |   AC   | 20/20 | 00.02s | 4696KB | 1013B |\n\n  \n","tags":["图论","普里姆算法","克鲁斯卡尔算法","最小生成树"],"categories":["图论"]},{"title":"Hello World","url":"/2022/01/08/hello-world/","content":"emmm...\n"}]