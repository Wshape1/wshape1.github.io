[{"title":"最小生成树(Minimum Spanning Tree)","url":"/2022/02/23/minimum_spanning_tree/","content":"\n## 前言\n\n例题：[AizuOJ ALDS_12A](https://onlinejudge.u-aizu.ac.jp/courses/lesson/1/ALDS1/12/ALDS1_12_A)  &  [AizuOJ GRL_2_A](https://onlinejudge.u-aizu.ac.jp/courses/library/5/GRL/2/GRL_2_A )\n\n本题可以使用**普里姆(Prim)算法**或**克鲁斯卡尔(Kruskal)算法**进行实现。\n\n两种算法的简单比较：\n\n|         |      时间复杂度       | 最适合 |\n| :-----: | :-------------------: | :----: |\n|  Prim   |        O(n^2)         | 稠密图 |\n| Kruskal | O(E * log E)，E为边数 | 稀疏图 |\n\n视频：[最小生成树(Kruskal(克鲁斯卡尔)和Prim(普里姆))算法动画演示](https://www.bilibili.com/video/BV1Eb41177d1 \"WAY_zhong - BiliBili\")\n\n以下代码是 [AizuOJ GRL_2_A](https://onlinejudge.u-aizu.ac.jp/courses/library/5/GRL/2/GRL_2_A ) 的解法。\n\n## 普里姆算法\n\n代码如下：\n\n```c++\n#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <limits.h>\n\nusing namespace std;\n\n#define MAX 10000\n\ntypedef pair<int, int> PII;\n\nvector<PII> D[MAX]; \t//PII(id, w)\nint sum = 0, d[MAX];\n//int p[MAX];\nbool seen[MAX] = {false};\n\nint main() {\n\tint V, E, s, t, w;\n\n\tscanf(\"%d %d\", &V, &E);\n\n\tfor (int i = 0; i < V; i++) {\n\t\td[i] = INT_MAX;\n\t}\n\n\tfor (int i = 0; i < E; i++) {\n\t\tscanf(\"%d %d %d\", &s, &t, &w);\n\t\tD[s].push_back(PII(t, w));\n\t\tD[t].push_back(PII(s, w));\n\t}\n\n\tint ct = 0;\n\ts = 0;\n\tseen[0] = true;\n\n\twhile (ct < V - 1) {\n\t\tfor (int i = 0; i < D[s].size(); i++) {\n\t\t\tt = D[s][i].first;\n\t\t\tw = D[s][i].second;\n\t\t\tif (!seen[t] && d[t] > w) {\n\t\t\t\td[t] = w;\n//\t\t\t\tp[t] = u;\n\t\t\t}\n\t\t}\n\n\t\tint min = 0;\n\t\tfor (int i = 0; i < V; i++)\n\t\t\tif (!seen[i] && d[i] < d[min])\n\t\t\t\tmin = i;\n\n\t\tseen[min] = true;\n\t\ts = min;\n\t\tsum += d[min];\n\t\tct++;\n\t}\n\n\tprintf(\"%d\\n\", sum);\n\n\treturn 0;\n}\n```\n\n运行结果：\n\n| Lang | Status | Judge |  Time  | Memory | Code |\n| :--: | :----: | :---: | :----: | :----: | :--: |\n| C++  |   AC   | 20/20 | 00.22s | 6024KB | 861B |\n\n## 克鲁斯卡尔算法\n\n代码如下：\n\n```c++\n#include <iostream>\n#include <cstdio>\n#include <vector>\n#include <algorithm>\n#include <limits.h>\n\nusing namespace std;\n\n#define MAX 10000\n\ntypedef struct {\n\tint v1, v2, w;\n} Info;\n\nvector<Info> D;\nint p[MAX], h[MAX], d[MAX];\n\nbool cmp(const Info a, const Info b) {\n\treturn a.w < b.w;\n}\n\nint find(int a) {\n\tif (p[a] != a) {\n\t\tp[a] = find(p[a]);\n\t}\n\treturn p[a];\n}\n\nvoid unite(int x, int y) {\n\tint rX = find(x);\n\tint rY = find(y);\n\n\tif (rX != rY) {\n\t\tif (h[rX] > h[rY])\n\t\t\tp[rY] = rX;\n\t\telse {\n\t\t\tp[rX] = rY;\n\t\t\tif (h[rX] == h[rY])\n\t\t\t\th[rY]++;\n\t\t}\n\t}\n}\n\n\nint main() {\n\tint V, E, sum = 0;\n\tint s, t, w;\n\n\tscanf(\"%d %d\", &V, &E);\n\n\tfor (int i = 0; i < V; i++) {\n\t\td[i] = INT_MAX;\n\t\tp[i] = i;\n\t\th[i] = 0;\n\t}\n\n\tfor (int i = 0; i < E; i++) {\n\t\tscanf(\"%d %d %d\", &s, &t, &w);\n\t\tInfo tmp = {s, t, w};\n\t\tD.push_back(tmp);\n\t}\n\n\tsort(D.begin(), D.end(), cmp);\n\n\tfor (int i = 0; i < E; i++) {\n\t\tif (find(D[i].v1) != find(D[i].v2)) {\n\t\t\tunite(D[i].v1, D[i].v2);\n\t\t\tsum += D[i].w;\n\t\t}\n\t}\n\n\tprintf(\"%d\\n\", sum);\n\n\treturn 0;\n}\n```\n\n运行结果：\n\n| Lang | Status | Judge |  Time  | Memory | Code  |\n| :--: | :----: | :---: | :----: | :----: | :---: |\n| C++  |   AC   | 20/20 | 00.02s | 4696KB | 1013B |\n\n  \n","tags":["图论","克鲁斯卡尔算法","普里姆算法","最小生成树"],"categories":["图论"]},{"title":"Hello World","url":"/2022/01/08/hello-world/","content":"emmm...\n"}]